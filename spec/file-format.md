# Fractal Code File Format Specification (JSON — Historical)

**Version 0.1 — Superseded**

> **Note:** This document describes the original JSON-based `.fc` format. It is retained as a historical reference. The canonical `.fc` specification is now **[fc-syntax.md](./fc-syntax.md)**, which defines a YAML-based native syntax optimized for AI agent generation and human readability.

## Overview

Fractal Code source files use the `.fc` extension. Unlike traditional programming languages designed around human-readable text syntax, `.fc` files are structured documents optimized for machine authorship and parsing while remaining inspectable by humans.

The format is JSON-based, making it trivially parseable by any AI agent on any platform, while carrying the full universal contract as a first-class structural element.

## Why Not Text Syntax?

Traditional languages use text syntax because humans need to type and read code. AI agents have no such constraint. They benefit from:

- **Structured data** over text parsing — no ambiguous grammar, no whitespace sensitivity
- **Explicit contracts** over inferred interfaces — every cell declares its full contract inline
- **Embedded metadata** over external documentation — lineage, signatures, and context maps travel with the code

A `.fc` file is a cell. A cell is a `.fc` file. The file format *is* the architecture.

## File Structure

Every `.fc` file contains exactly one cell definition:

```json
{
  "$schema": "https://fractalcode.dev/schema/cell-v1.json",
  "identity": {
    "name": "greeter",
    "cellType": "transformer",
    "version": "1.0.0"
  },
  "input": {
    "schema": { "type": "string" },
    "description": "A name to greet"
  },
  "output": {
    "schema": { "type": "string" },
    "description": "A greeting message"
  },
  "health": {
    "complexityBudget": 100
  },
  "lineage": {
    "source": "Claude-Opus-4.6",
    "trigger": "constitution-v1.0-step5",
    "justification": "Provides stateless greeting transformation for the pipeline",
    "signature": "0000000000000000000000000000000000000000000000000000000000000000"
  },
  "signature": {
    "hash": "96154676c255b09ef9bea0106d1d6b44...",
    "timestamp": "2026-02-16T00:00:00.000Z"
  },
  "implementation": {
    "language": "typescript",
    "entrypoint": "process",
    "source": "async (name: string) => `Hello, ${name}! Welcome to Fractal Code.`"
  },
  "children": [],
  "channels": []
}
```

## Sections

### `$schema` (required)

A reference to the JSON schema that validates this cell definition. Enables tooling to validate `.fc` files without the constitutional validator.

### `identity` (required)

The cell's identity per the universal contract.

```json
{
  "name": "<string>",
  "cellType": "transformer" | "reactor" | "keeper" | "channel",
  "version": "<semver>"
}
```

### `input` (required)

```json
{
  "schema": { /* JSON Schema */ },
  "description": "<string>"
}
```

### `output` (required)

```json
{
  "schema": { /* JSON Schema */ },
  "description": "<string>"
}
```

### `health` (required)

Circuit breaker configuration. For Transformers and Reactors, `complexityBudget` is mandatory.

```json
{
  "complexityBudget": 1000
}
```

### `lineage` (required)

The Intent Ledger. All four fields are mandatory.

```json
{
  "source": "<Agent ID>",
  "trigger": "<Prompt ID | Issue # | Decision Record>",
  "justification": "<one sentence>",
  "signature": "<64-char hex — Merkle hash of parent context>"
}
```

### `signature` (required)

The Structural Signature, auto-generated by the SDK or compiler.

```json
{
  "hash": "<64-char hex SHA-256>",
  "children": ["<child-hash>", "..."],
  "timestamp": "<ISO 8601>"
}
```

### `implementation` (required)

The executable logic of the cell. In the initial version, this embeds source code in a host language (TypeScript). Future versions may define a native Fractal Code instruction set.

```json
{
  "language": "typescript",
  "entrypoint": "process" | "on" | "get" | "set" | "send" | "receive",
  "source": "<string — the function body>"
}
```

The `entrypoint` corresponds to the cell type's primary method:
- Transformer → `process`
- Reactor → `on`
- Keeper → `get` / `set`
- Channel → `send` / `receive`

### `children` (optional)

For composed cells — an array of references to child `.fc` files:

```json
{
  "children": [
    { "ref": "./request.reactor.fc" },
    { "ref": "./pipe.channel.fc" },
    { "ref": "./greeter.transformer.fc" },
    { "ref": "./memory.keeper.fc" }
  ]
}
```

### `channels` (optional)

Declares which Channel children mediate sibling communication:

```json
{
  "channels": [
    {
      "name": "pipe",
      "connects": [
        { "from": "request", "to": "greeter" },
        { "from": "greeter", "to": "memory" }
      ]
    }
  ]
}
```

## File Naming Convention

```
<name>.<cell-type>.fc
```

Examples:
- `greeter.transformer.fc`
- `request.reactor.fc`
- `memory.keeper.fc`
- `pipe.channel.fc`
- `app.transformer.fc` (root cell)

## Directory Convention

A Fractal Code project is a directory containing `.fc` files. The root cell is the entry point.

```
my-project/
├── app.transformer.fc        # Root cell
├── request.reactor.fc
├── pipe.channel.fc
├── greeter.transformer.fc
├── memory.keeper.fc
└── fractal.json               # Project manifest
```

### `fractal.json` — Project Manifest

```json
{
  "name": "my-project",
  "version": "1.0.0",
  "root": "app.transformer.fc",
  "constitution": "1.1"
}
```

## Validation

A `.fc` file is valid if:

1. It is valid JSON
2. It contains all required sections (identity, input, output, health, lineage, signature, implementation)
3. The `identity.cellType` is one of the four defined types
4. The `lineage` conforms to the Intent Ledger schema (all four fields non-empty)
5. The `signature.hash` is a valid 64-character hex string
6. For Transformers and Reactors: `health.complexityBudget` is present and positive
7. If `children` are declared, at least one Channel must be present in `channels`
8. The file name matches the pattern `<name>.<cellType>.fc`

The constitutional validator will be extended to parse `.fc` files directly in a future release.

## Future Directions

- **Native instruction set:** Replace embedded TypeScript with a Fractal Code native bytecode optimized for AI execution
- **Binary format:** A compact binary encoding of `.fc` files for performance-critical deployments
- **Streaming format:** Support for `.fc` files that represent infinite streams or long-running processes
- **Cross-language implementation:** `implementation.language` may be `python`, `rust`, `go`, etc.
